[["index.html", "MATH 376: Algebraic Structures Preface", " MATH 376: Algebraic Structures Preface This is the class handbook for Math 376 Algebraic Structures at Macalester College. The content here was made by Tom Halverson in the Department of Mathematics, Statistics and Computer Science at Macalester College. This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["problem-set-1.html", "Section 1 Problem Set 1 1.1 Modular Multiplication 1.2 Group of Units \\(U_n\\) mod n 1.3 Two-by-two mod 2 1.4 Outer Cancellation 1.5 Distributing Powers 1.6 Cyclic Subgroups", " Section 1 Problem Set 1 Due: Friday March 26, 5:00PM CST. You should upload your assignment under the PS1 link on Moodle. You can hand write your solutions and scan them, or typeset them in R or LaTex. But you should upload the assignment in a single PDF or a single HTML file. Ideally, submit the problems in order, but if that is not possible, the problems should be clearly labeled. You should justify all answers, unless the assignment is to compute something. Then you should clearly display your computed work. All assignments will be out of 30 points. For example, this assignment has six 5-point problems. Late work: assignments will be lowered by 10% each day they are late. The solution will be posted on Tuesday. From that point on, I will still accept assignment write-ups, but you can earn a maximum of half of the points. Collaboration is encouraged. In fact, it has been shown that people who form study groups, and talk about assignments, learn more and perform better. However, you should write up your own work in your own words (blatent copying is not acceptable), and if you receive substantial help from a classmate, you should give that person credit in your write-up (no pentalty for this!). 1.1 Modular Multiplication Make the multiplication tables of the following sets and determine which of them are groups under multiplication. You can do this by hand (encouraged to get the feel for it) or using the R commands in [Modular Arithemtic]. \\(\\{1,2,3\\}\\) using multiplication mod 4 \\(\\{1,2,3,4\\}\\) using multiplication mod 5 \\(\\{1,5,7,11\\}\\) using multiplication mod 12 \\(\\{5,15,25,35\\}\\) using multiplication mod 40 1.2 Group of Units \\(U_n\\) mod n Let \\(U_n = \\{1 \\le k &lt; n \\mid 1 = \\gcd(k,n) \\}\\). These are the elements of \\(\\mathbb{Z}_n\\) that are relatively prime to \\(n\\). Note: the book denotes this by \\(U(n)\\). In this problem, we will explore this set and prove that it is a group. Notice: by definition \\(U_n\\) has the multiplicative identity 1, since \\(gcd(1,n) = 1\\). And, multiplication mod n is associative. So, we need to make sure it is a binary operation on \\(U_n\\) and that \\(U_n\\) is closed under taking inverses. Compute the sets \\(U_6,U_7,U_8\\). Use the R-code in Modular Arithmetic to do the following (you can do it by hand if you prefer). Make the multiplication tables of \\(\\mathbb{Z}_8\\) and \\(U_8\\) mod 8. Make the multiplication table of \\(U_9\\). Make the multiplication table of \\(U_{14}\\). Show that if \\(a \\in U_n\\) then \\(a\\) has a multiplicative inverse in \\(U_n\\). Hint: use the Extended GCD from Chapter 0, the cyclic groups voicethread, and Modular Arithmetic. Show that \\(U_n\\) is closed under multiplication. That is if \\(a, b \\in U_n\\), then \\(ab \\in U_n\\). This shows that multiplication mod \\(n\\) is a binary operation on \\(U_n\\). Hint 1: if \\(a\\) is invertible mod n and \\(b\\) is invertible mod n, then must \\(ab\\) be invertible mod \\(n\\). Hint 2: think about your shoes and socks. Are \\(U_8\\), \\(U_9\\), and/or \\(U_{14}\\) cyclic? Justify your answers. 1.3 Two-by-two mod 2 The group \\(GL_2(\\mathbb{Z}_2)\\) is the group of all invertible \\(2\\times 2\\) matrices with entries from \\(\\mathbb{Z}_2 = \\{0,1\\}\\) and all arithmetic done mod 2. That is, \\[ GL_2(\\mathbb{Z}_2) = \\left\\{ A=\\begin{pmatrix} a &amp; b \\\\ c &amp; d \\end{pmatrix} \\mid a,b,c,d \\in \\{0,1\\} \\hbox{ and $A$ is invertible} \\right\\}. \\] The operation is usual matrix multiplication with arithmetic done mod 2 so that: 0+0 = 0, 0+1 = 1+0 = 1, 1+1 = 0. There are 16 matrices of this form (two choices 0 or 1 for each of the four matrix entries), determine which of these are invertible (you can use the determinant mod 2). Let \\(A\\) and \\(B\\) be the matrices below \\[ A = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 1 \\end{pmatrix} \\qquad\\hbox{and}\\qquad B = \\begin{pmatrix} 1 &amp; 1 \\\\ 0 &amp; 1 \\end{pmatrix}. \\] Show that every element in this group is of the form \\(A^i B^j\\) for some powers \\(i\\) and \\(j\\) (these powers can be 0). Since \\(BA\\) is in the group, it must be equal to \\(A^i B^j\\) for some \\(i\\) and \\(j\\). Find \\(i\\) and \\(j\\). 1.4 Outer Cancellation A group \\(\\mathsf{G}\\) has the special property that for all \\(x,y,z \\in G\\), if \\(xy = zx\\) then \\(y = z\\). Prove that \\(\\mathsf{G}\\) is abelian. 1.5 Distributing Powers Prove that for \\(a, b\\) in a group \\(\\mathsf{G}\\) we have \\[ (ab)^2=a^2b^2 \\quad \\hbox{ if and only if } \\quad ab=ba. \\] 1.6 Cyclic Subgroups If \\(g \\in \\mathsf{G}\\), then \\(\\langle g \\rangle \\le \\mathsf{G}\\) is the smallest subgroup of \\(\\mathsf{G}\\) that contains \\(g\\). We will show in class that \\[ \\begin{array}{rcll} \\langle g \\rangle &amp;=&amp; \\{ g^k \\mid k \\in \\mathbb{Z}\\}, &amp; \\hbox{if $|g| = \\infty$}.\\\\ \\langle g \\rangle &amp;=&amp; \\{1, g, g^2, \\ldots, g^{n-1}\\}, \\quad &amp; \\hbox{if $|g| = n$}.\\\\ \\end{array} \\] Compute the elements of the following cyclic subgroups. \\(\\langle 5 \\rangle \\le \\mathbb{Z}\\) \\(\\langle 5 \\rangle \\le \\mathbb{Z}_{30}\\) \\(\\langle 5 \\rangle \\le \\mathbb{R}^\\ast\\) \\(\\langle 5 \\rangle \\le U_{28}\\) \\(\\langle (\\frac{\\sqrt{2}}{2} + \\frac{\\sqrt{2}}{2}i) \\rangle \\le \\mathbb{C}^\\ast\\) "],["cyclic-groups.html", "Section 2 Cyclic Groups 2.1 Overview", " Section 2 Cyclic Groups 2.1 Overview The finite cyclic group \\(\\mathbb{Z}_{n} = \\{ 0, 1, 2, \\ldots, n-1\\}\\) is the group under addition mod \\(n\\). For example, here is the Cayley table of \\(\\mathbb{Z}_{10}\\). See Modular Arithmetic for the R function that produces these tables for any value of \\(n\\). CyclicCayley(10) ## 0 1 2 3 4 5 6 7 8 9 ## 0 0 1 2 3 4 5 6 7 8 9 ## 1 1 2 3 4 5 6 7 8 9 0 ## 2 2 3 4 5 6 7 8 9 0 1 ## 3 3 4 5 6 7 8 9 0 1 2 ## 4 4 5 6 7 8 9 0 1 2 3 ## 5 5 6 7 8 9 0 1 2 3 4 ## 6 6 7 8 9 0 1 2 3 4 5 ## 7 7 8 9 0 1 2 3 4 5 6 ## 8 8 9 0 1 2 3 4 5 6 7 ## 9 9 0 1 2 3 4 5 6 7 8 "],["important-definitions-and-theorems.html", "Section 3 Important Definitions and Theorems 3.1 Groups", " Section 3 Important Definitions and Theorems 3.1 Groups 3.1.1 Group Def: A group is a set \\(\\mathsf{G}\\) with a binary operation \\(\\ast\\) that satisfies the following: (Identity) There exists \\(e \\in \\mathsf{G}\\) such that: if \\(g \\in \\mathsf{G}\\), then \\(e \\ast g= g \\ast e = g\\). (Inverse) If \\(g \\in \\mathsf{G}\\), then there exists \\(g^{-1} \\in \\mathsf{G}\\) so that \\(g \\ast g^{-1} = g^{-1} \\ast g = e\\). (Associativity) If \\(a,b,c \\in \\mathsf{G}\\), then \\((ab)c = a (bc)\\). Furthermore, the group is abelian if it also satisfies the commutative property: (Commutative) If \\(a,b \\in \\mathsf{G}\\), then \\(ab = ba\\). 3.1.2 Subgroup Def: A subset \\(\\mathsf{H}\\subseteq \\mathsf{G}\\) of a group \\(\\mathsf{G}\\) is a subgroup if \\(\\mathsf{H}\\) is a group under the same binary operation that it inherits from \\(\\mathsf{G}\\). We write \\(\\mathsf{H}\\le \\mathsf{G}\\) do denote that \\(\\mathsf{H}\\) is a subgroup of \\(\\mathsf{G}\\) and write \\(\\mathsf{H}&lt; \\mathsf{G}\\) if \\(\\mathsf{H}\\le \\mathsf{G}\\) and \\(\\mathsf{H}\\not= \\mathsf{G}\\). Theorem: (Subgroup Test) A nonempty subset \\(\\mathsf{H}\\subseteq \\mathsf{G}\\) is a subgroup if (identity) \\(e \\in \\mathsf{H}\\), where \\(e\\) is the identity in \\(\\mathsf{G}\\). (closure) If \\(h_1, h_2 \\in \\mathsf{H}\\), then \\(h_1 h_2 \\in \\mathsf{H}\\). (contains inverses) If \\(h \\in \\mathsf{H}\\), then \\(h^{-1} \\in \\mathsf{H}\\). Note: (a) follows from (b) and (c). "],["modular-arithmetic.html", "Section 4 Modular Arithmetic 4.1 Integer division and GCD 4.2 Addition Mod n: \\(\\mathbb{Z}_n\\) 4.3 Multiplication Mod n: \\(U_n\\)", " Section 4 Modular Arithmetic We will require the package pracma, which you may recall from linear algebra, contains “practical math applications.” It has implementations of modular arithmetic and the GCD algorithms. require(pracma) 4.1 Integer division and GCD The mod function computes the remainder after division by \\(n\\) idivide gives the quotient. Thus, for example, mod(68,15) ## [1] 8 idivide(68,15) ## [1] 4 Since \\(68 = 15 \\cdot 4 + 8\\). The greatest commond diviso GCD of two integers is computed with the gcd(m,n) command. For example, gcd(70,42) ## [1] 14 gcd(68,15) ## [1] 1 telling us that \\(gcd(70,42) = 14\\) and \\(gcd(68,15) = 1\\), meaning that 68 and 15 are relatively prime. The Extended GCD gives a little more information that can be quite useful in this course. If \\(d = gcd(a,b)\\) then there exist integers \\(s,t \\in \\mathbb{Z}\\) such that \\[ d = s a+ t b. \\] You can find a proof of this fact in Chapter 0. We can use it here: gcd(70,42,extended=TRUE) ## $g ## [1] 14 ## ## $c ## [1] -1 ## ## $d ## [1] 2 gcd(68,15,extended=TRUE) ## $g ## [1] 1 ## ## $c ## [1] 2 ## ## $d ## [1] -9 Telling us that \\[ \\begin{align*} 14 &amp; = (-1) 70 + (2) 42 \\\\ 1 &amp; = (2)68 + (-9) 15 \\end{align*} \\] As we can confirm with 2*68 - 9*15 ## [1] 1 4.2 Addition Mod n: \\(\\mathbb{Z}_n\\) We can generate the finite cyclic group \\(\\mathbb{Z}_n = \\{0, 1, 2, \\ldots, n-1\\}\\) easily as follows: n = 12 G = 0:(n-1) # generates an integer sequence from 0 to n-1. G ## [1] 0 1 2 3 4 5 6 7 8 9 10 11 And then we can add all of these elements mod n and make the Cayley table as follows: n=6 G = 0:(n-1) T = mod(outer(G,G,&quot;+&quot;),n) # the outer sum computes a table of sums i + j rownames(T) = G colnames(T) = G T ## 0 1 2 3 4 5 ## 0 0 1 2 3 4 5 ## 1 1 2 3 4 5 0 ## 2 2 3 4 5 0 1 ## 3 3 4 5 0 1 2 ## 4 4 5 0 1 2 3 ## 5 5 0 1 2 3 4 Evem better, we can write a little function to do this. CyclicCayley &lt;- function(n,op=&quot;+&quot;) { G = 0:(n-1) T = mod(outer(G,G,op),n) rownames(T) = G colnames(T) = G return(T) } Then CyclicCayley(5) ## 0 1 2 3 4 ## 0 0 1 2 3 4 ## 1 1 2 3 4 0 ## 2 2 3 4 0 1 ## 3 3 4 0 1 2 ## 4 4 0 1 2 3 and CyclicCayley(15) ## 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 0 ## 2 2 3 4 5 6 7 8 9 10 11 12 13 14 0 1 ## 3 3 4 5 6 7 8 9 10 11 12 13 14 0 1 2 ## 4 4 5 6 7 8 9 10 11 12 13 14 0 1 2 3 ## 5 5 6 7 8 9 10 11 12 13 14 0 1 2 3 4 ## 6 6 7 8 9 10 11 12 13 14 0 1 2 3 4 5 ## 7 7 8 9 10 11 12 13 14 0 1 2 3 4 5 6 ## 8 8 9 10 11 12 13 14 0 1 2 3 4 5 6 7 ## 9 9 10 11 12 13 14 0 1 2 3 4 5 6 7 8 ## 10 10 11 12 13 14 0 1 2 3 4 5 6 7 8 9 ## 11 11 12 13 14 0 1 2 3 4 5 6 7 8 9 10 ## 12 12 13 14 0 1 2 3 4 5 6 7 8 9 10 11 ## 13 13 14 0 1 2 3 4 5 6 7 8 9 10 11 12 ## 14 14 0 1 2 3 4 5 6 7 8 9 10 11 12 13 4.3 Multiplication Mod n: \\(U_n\\) The functions below will give us \\(\\mathbb{Z}_n\\) and \\(U_n\\). Cyclic &lt;- function(n) { 0:(n-1) } Units &lt;- function(n) { (1:(n-1))[gcd(1:(n-1),n)==1] } For example, Cyclic(10) ## [1] 0 1 2 3 4 5 6 7 8 9 Units(10) ## [1] 1 3 7 9 We can multiply these by writing a MultTable function that uses the outer product MultTable &lt;- function(G,n,op=&quot;*&quot;) { T = mod(outer(G,G,op),n) rownames(T) = G colnames(T) = G return(T) } And we try it out: MultTable(Cyclic(10),10) ## 0 1 2 3 4 5 6 7 8 9 ## 0 0 0 0 0 0 0 0 0 0 0 ## 1 0 1 2 3 4 5 6 7 8 9 ## 2 0 2 4 6 8 0 2 4 6 8 ## 3 0 3 6 9 2 5 8 1 4 7 ## 4 0 4 8 2 6 0 4 8 2 6 ## 5 0 5 0 5 0 5 0 5 0 5 ## 6 0 6 2 8 4 0 6 2 8 4 ## 7 0 7 4 1 8 5 2 9 6 3 ## 8 0 8 6 4 2 0 8 6 4 2 ## 9 0 9 8 7 6 5 4 3 2 1 MultTable(Units(10),10) ## 1 3 7 9 ## 1 1 3 7 9 ## 3 3 9 1 7 ## 7 7 1 9 3 ## 9 9 7 3 1 "],["matrix-groups.html", "Section 5 Matrix Groups 5.1 The General Linear Group \\(GL_n(\\mathbb{R})\\) 5.2 Matrix Multiplication Mod m: \\(GL_n(\\mathbb{Z}_m)\\)", " Section 5 Matrix Groups require(pracma) 5.1 The General Linear Group \\(GL_n(\\mathbb{R})\\) The general linear group \\(GL_n(\\mathbb{R})\\) is the group of all invertible \\(n \\times n\\) matrices with entries from the real numbers \\(\\mathbb{R}\\). This is the world we lived in when we worked with square invertible matrices (and the invertible matrix theorem) in Math 236 Linear Algebra. Remember that R has a funny matrix multiplication symbol: %*%. For example, A = cbind(c(1,2,3),c(1,1,1),c(0,1,1)) B = cbind(c(-5,1,1),c(1,1,3),c(1,2,1)) A %*% B ## [,1] [,2] [,3] ## [1,] -4 2 3 ## [2,] -8 6 5 ## [3,] -13 7 6 B %*% A ## [,1] [,2] [,3] ## [1,] 0 -3 2 ## [2,] 9 4 3 ## [3,] 10 5 4 illustrating that matrix multiplication is not-commutative and \\(GL_n(\\mathbb{R})\\) is a nonabelian group. The identity matrix is the identity element of the group, and it can be defined with diag(n). If you have pracma loaded then you can invert the matrix A with inv(A) otherwise, in base R, you can use solve(A). inv(A) ## [,1] [,2] [,3] ## [1,] 0 -1 1 ## [2,] 1 1 -1 ## [3,] -1 2 -1 zapsmall(A %*% inv(A)) ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 diag(3) %*% A ## [,1] [,2] [,3] ## [1,] 1 1 0 ## [2,] 2 1 1 ## [3,] 3 1 1 5.2 Matrix Multiplication Mod m: \\(GL_n(\\mathbb{Z}_m)\\) You can use the mod command from pracma to do matrix multiplication mod m. For example, notice how the product looks very different for different \\(\\mathbb{Z}_m\\). A = rbind(c(1,3),c(2,7)) B = rbind(c(5,4),c(-3,-2)) A %*% B ## [,1] [,2] ## [1,] -4 -2 ## [2,] -11 -6 mod(A %*% B,2) ## [,1] [,2] ## [1,] 0 0 ## [2,] 1 0 mod(A %*% B,3) ## [,1] [,2] ## [1,] 2 1 ## [2,] 1 0 mod(A %*% B,4) ## [,1] [,2] ## [1,] 0 2 ## [2,] 1 2 "],["complex-n-th-roots-of-unity.html", "Section 6 Complex n-th roots of unity", " Section 6 Complex n-th roots of unity More information forthcoming. Here are the complex 14-th roots of unity. These are the 14 solutions to the equation \\(x^{14} - 1 = 0\\). There are only 2 real solutions \\(1\\) and \\(-1\\). n = 14 ii = 0+1i w = exp(2*pi*ii/n) G = w^(0:(n-1)) G ## [1] 1.0000000+0.0000000i 0.9009689+0.4338837i 0.6234898+0.7818315i 0.2225209+0.9749279i -0.2225209+0.9749279i ## [6] -0.6234898+0.7818315i -0.9009689+0.4338837i -1.0000000+0.0000000i -0.9009689-0.4338837i -0.6234898-0.7818315i ## [11] -0.2225209-0.9749279i 0.2225209-0.9749279i 0.6234898-0.7818315i 0.9009689-0.4338837i plot(Re(G),Im(G),col=&#39;red&#39;,pch=19) grid() "]]
